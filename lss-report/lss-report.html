<!doctype html>
<html>
   <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="generator" content="pandoc">
      <meta name="author" content="Thomas AngeliniJacopo CorinaFrancesco GoriniRiccardo MaldiniFilippo Nardini">
      
      <title>ScalaQuest LSS Report</title>
      <!-- Bootstrap -->
      <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
      <!-- Font-awesome -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
      <!-- Styles -->
      <link rel="stylesheet" href="https://ashki23.github.io/styles.css">
      <link rel="stylesheet" href="https://scalaquest.github.io/PandocBootstrap/customStyles.css">
      <link rel="icon" type="image/png" sizes="32x32" href="https://scalaquest.github.io/PandocBootstrap/favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="https://scalaquest.github.io/PandocBootstrap/favicon-16x16.png">
      <link rel="icon" type="image/x-icon" href="https://scalaquest.github.io/PandocBootstrap/favicon.ico" />
      <meta name="theme-color" content="#ffffff">
         </head>
   <body>
            <div class="container">
         <h1 class="title">ScalaQuest LSS Report</h1>
                  <div class="row">
            <div class="col-xl-9"><h1 data-number="1" id="sec:introduzione"><span class="header-section-number">1</span> Introduzione</h1>
<p>Il progetto ScalaQuest si pone come obiettivo quello di realizzare un framework per permettere l’implementazione di giochi del genere <strong><a href="https://en.wikipedia.org/wiki/Interactive_fiction">Interactive Fiction</a></strong> (come ad esempio <a href="https://en.wikipedia.org/wiki/Zork">Zork</a>), nei quali il giocatore può utilizzare comandi di testo per influenzare l’ambiente e proseguire nel gioco.</p>
<p>Esso dovrà in primis fornire una libreria, tale da permettere la <strong>creazione di storie giocabili</strong> da utenti terzi, tramite un API facilmente accessibile.</p>
<p>Dovrà inoltre fornire una <strong>piattaforma per l’esecuzione delle storie</strong>, basata su un’interfaccia da linea di comando. Questa permetterà ad utenti terzi di interagire con le storie create precedentemente, modificando lo stato nel gioco e avanzando man mano nella storia.</p>
<p>Il progetto è stato ideato per essere oggetto di esame in maniera mutuata per i corsi di PPS e LSS. A tale scopo, fin dalla definizione delle fondamenta del progetto si è posta particolare attenzione nell’adozione di una metodologia tale da integrare le peculiarità di entrambi i corsi. Il report di PPS descrive estensivamente gli aspetti relativi allo stesso corso, mentre nel report corrente vengono approfonditi nel dettaglio gli aspetti inerenti al corso di Laboratorio di Sistemi Software, tra cui:</p>
<ul>
<li>Il processo di sviluppo e di design, incentrato su un approccio di tipo Domain Driven;</li>
<li>Le pratiche DevOps poste in atto.</li>
</ul>
<p>In tutte le fasi il progetto è stato fortemente influenzato da questi aspetti, al quale è stato dedicato un ammontare di ore di lavoro equivalente a quello di PPS, considerando oltre alla mera implementazione anche il lavoro di approfondimento e studio delle pratiche, in parte nuove per i membri del team.</p>
<h2 data-number="1.1" id="sec:sorgenti"><span class="header-section-number">1.1</span> Sorgenti</h2>
<p>Complessivamente, i sorgenti di progetto consistono nell’insieme di repository GitHub parte dell’<a href="https://github.com/scalaquest">organizzazione ScalaQuest</a>.</p>
<p>Tutti i sorgenti sono resi disponibile sotto <strong>licenza MIT</strong>, in quanto chiara, breve e concisa. Non vengono poste particolari limitazioni riguardo la consultazione e il riuso da parte di terzi del software fornito.</p>
<p>Ulteriori informazioni, documentazione e guide possono essere reperite a partire dal <a href="https://scalaquest.github.io/PPS-19-ScalaQuest">sito di progetto</a>.</p>
<h1 data-number="2" id="sec:aspetti-di-domain-driven-design"><span class="header-section-number">2</span> Aspetti di Domain Driven Design</h1>
<p>Sin dalle prime iterazioni di progetto, particolare attenzione è stata posta nell’utilizzo dell’approccio Domain Driven Design. Nella pratica, <a href="https://miro.com/app/board/o9J_lfd9ZK0=/">una board collaborativa <strong>Miro</strong></a> è stata utilizzata per mettere nero su bianco idee e concetti base. È bene sottolineare che oltre ai costrutti richiesti dal DDD, la board contiene anche molteplici sketch che hanno portato il gruppo alla definizione di vari componenti.</p>
<h2 data-number="2.1" id="sec:knowledge-crunching"><span class="header-section-number">2.1</span> Knowledge Crunching</h2>
<p>Prima ancora di mettere mano all’architettura di progetto, per diverse settimane sono state effettuate sessioni di knowledge crunching che hanno visto la partecipazione di tutti i membri del team. Scopo di queste sessioni era lo studio del dominio applicativo, e la definizione di requisiti tali da guidare lo sviluppo in un’ottica DDD.</p>
<p>In primo luogo si sono andati a delineare in linea di massima i casi d’uso, per poi definire Ubiquitous Language e Bounded Context. Alla prima bozza degli stessi sono seguiti raffinamenti successivi, fino alla definizione di una struttura quanto più precisa e dettagliata.</p>
<p>Dal documento di Scrum Overview allegato in appendice è possibile individuare chiaramente come il primo Sprint tracciato (quello conseguente all’approvazione del progetto da parte del prof. Viroli) è stato interamente dedicato a questa fase. È però importante sottolineare come il lavoro di knowledge crunching sia iniziato ben prima, seppur con minore impegno, già dagli inizi di dicembre, ovvero dalla data di sottomissione dello stesso.</p>
<h2 data-number="2.2" id="sec:ubiquitous-language"><span class="header-section-number">2.2</span> Ubiquitous Language</h2>
<p>Di particolare importanza si è rilevata l’individuazione di un Ubiquitous Language originato dai concetti base del progetto. In fig. 2.1 viene riportata la versione finale, che comprende tutti i concetti principali. Sulla <a href="https://miro.com/app/board/o9J_lfd9ZK0=/">board Miro</a> è disponibile una versione dello stesso nel quale viene ampliata la descrizione di ogni termine.</p>
<figure>
<img src="./images/ul.jpg" id="fig:ul" alt="Figure 2.1: Ubiquitous Language del progetto." /><figcaption aria-hidden="true">Figure 2.1: Ubiquitous Language del progetto.</figcaption>
</figure>
<h2 data-number="2.3" id="sec:individuazione-dei-requisiti-e-dei-casi-duso"><span class="header-section-number">2.3</span> Individuazione dei requisiti e dei casi d’uso</h2>
<p>Nell’ambito di progetto sono stati individuati due principali attori, tali da interagire con lo stesso. Sulla base della loro definizione, sono stati quindi individuati vari casi d’uso, riportati in fig. 2.2:</p>
<ul>
<li><p><strong>Storyteller</strong>: rappresenta l’attore in grado di creare delle storie giocabili. Questo è di fatto un programmatore che usufruisce del framework, e si assume quindi che abbia delle conoscenze di programmazione Scala. La creazione della storia consiste nella definizione delle <code>Room</code> e degli <code>Item</code> ad essa associati (includendo come parte di questa interazione la descrizione di <em>come</em> tali entità reagiscono ai comandi utente), e alla definizione dei verbi che comporranno la grammatica di una specifica storia;</p></li>
<li><p><strong>User</strong>: il termine indica l’attore che usufruisce della storia giocabile. Esso interagisce con il sistema immettendo comandi testuali, e consultandone l’output risultante.</p></li>
</ul>
<figure>
<img src="./images/use-case.jpg" id="fig:usecase" alt="Figure 2.2: Diagramma dei casi d’uso del progetto." /><figcaption aria-hidden="true">Figure 2.2: Diagramma dei casi d’uso del progetto.</figcaption>
</figure>
<h2 data-number="2.4" id="sec:bounded-context-e-context-map"><span class="header-section-number">2.4</span> Bounded context e Context map</h2>
<p>A seguito dell’individuazione dei casi d’uso, si è andata a espandere l’analisi al fine di individuare i principali bounded context associati al progetto.</p>
<figure>
<img src="./images/bounded-context-analysis.jpg" id="fig:bcontextan" alt="Figure 2.3: Analisi dei bounded context di progetto." /><figcaption aria-hidden="true">Figure 2.3: Analisi dei bounded context di progetto.</figcaption>
</figure>
<p>L’immagine fig. 2.3 riporta i principali bounded context, posti nel grafico in base alla complessità di modellazione degli stessi e all’importanza per il business. Si è intesa quest’ultima misura come la rilevanza di tale context, dal punto di vista di user e storyteller. Dal grafico si può evincere anche come le operazioni DevOps siano state elevate a vero e proprio bounded context: in ottica di effettuare un progetto di esame per LSS, esso rappresenta un vero e proprio requisito, ad alta complessità. L’utente finale, inteso come storyteller/user, può percepire da tali operazioni benefici indiretti (es. nella velocità delle release, nella qualità dell’API).</p>
<p>Sulla base di questa analisi preliminare, si è andata quindi a definire la context map, mostrata in fig. 2.4.</p>
<figure>
<img src="./images/context-map.jpg" id="fig:contextmap" alt="Figure 2.4: Context map di progetto." /><figcaption aria-hidden="true">Figure 2.4: Context map di progetto.</figcaption>
</figure>
<p>Nello specifico, si è andato a accorpare quelli che erano stati individuati come bounded context di primaria importanza, in un unico <strong>Core</strong> bounded context. Questo in quanto, concettualmente, rappresentano moduli strettamente collegati.</p>
<p>Il bounded context <strong>Storyteller Application</strong> include ciò che concerne l’implementazione di vere e proprie UI per l’interazione con l’utente. HTML è stato rappresentato come tratteggiato, in quanto rappresenta un elemento da valutare in corso d’opera.</p>
<p><strong>Storyteller Support</strong> include tutto ciò che concerne il supporto per lo storyteller alla costruzione della propria storia. In una libreria di queste dimensioni, fornire della documentazione di supporto diventa infatti un requisito di primaria importanza.</p>
<p>Infine, è stato definito un bounded context anche per ciò che concerne le pratiche <strong>DevOps</strong>. Graficamente, essi sono sono collegati agli altri bounded context. Ma non per il fatto di non influenzare gli altri; anzi, i collegamenti non sono rappresentati per il semplice fatto che il primo contiene degli elementi per loro natura pervasivi, che influenzano in maniera indiretta a tutti gli altri bounded context.</p>
<h1 data-number="3" id="sec:gradle-e-struttura-multi-progetto"><span class="header-section-number">3</span> Gradle e struttura multi-progetto</h1>
<p>Una volta definiti i bounded context, si è proseguito andando a definire l’architettura di progetto. È stata predisposta la repository di base, dal nome <a href="https://github.com/scalaquest/PPS-19-ScalaQuest">scalaquest/PPS-19-ScalaQuest</a>, come richiesto da specifiche di PPS. È qui che risiede il sorgente alla base dei principali moduli.</p>
<p>Si è deciso di utilizzare il tool di build automation <strong>Gradle</strong> per strutturare il progetto. Pur non essendo pensato primariamente per il linguaggio Scala, Gradle fornisce supporto per lo stesso.</p>
<p>Si è predisposta una <strong>struttura multi-progetto</strong> il più possibile aderente all’analisi DDD effettuata. Sono stati definiti i seguenti sotto-progetti:</p>
<ul>
<li><p><strong>Core</strong>: modulo che va a rappresentare di fatto il bounded context Core. Esso è stato pensato infatti per definire specifiche alla base del model, della pipeline di progetto, la definizione dell’API per lo storyteller, e l’engine Prolog del gioco per l’interpretazione dei comandi;</p></li>
<li><p><strong>CLI</strong>: modulo che va a mappare l’elemento CLI del bounded context Storyteller Application. Rappresenta una “piattaforma” sulle quali giocare le storie, basata su un’implementazione a linea di comando. A livello pratico, <em>CLI</em> eredita come dipendenza il modulo <em>Core</em>, permettendo allo storyteller di iniziare a creare storie importando il solo modulo <em>CLI</em>.</p></li>
<li><p><strong>Examples</strong>: sono stati definiti diversi moduli che consistono di fatto in delle storie di esempio, giocabili da un’utente finale.</p></li>
</ul>
<h2 data-number="3.1" id="sec:strategia-basata-su-convention-plugin"><span class="header-section-number">3.1</span> Strategia basata su convention plugin</h2>
<p>Ogni modulo necessita di differenti plugin Gradle per poter funzionare correttamente. Il dettaglio dei plugin specifici richiesti da ogni modulo viene trattato nei capitoli successivi.</p>
<p>Di particolare interesse è invece una scelta architetturale che ha permesso di condividere, tra vari insiemi di sub-projects, plugin e configurazioni comuni. Si è infatti deciso di sfruttare una strategia fortemente raccomandata da Gradle nella sua documentazione, basata sui <strong>convention plugin</strong>.</p>
<p>Questa consiste nella definizione di vari plugin custom all’interno della directory standard <code>/buildSrc</code>, ognuno comprendente configurazioni comuni a più sotto-progetti, inscrivibili in determinate categorie. Una volta definiti, è quindi possibile includere tutte le configurazioni comuni semplicemente includendo all’interno dei singoli sotto-progetti i convention plugin richiesti. In particolare:</p>
<ul>
<li><p><strong>scalaquest.common-scala-conventions</strong>: definisce le configurazioni comuni a tutti i sotto-progetti basati su linguaggio Scala (di fatto, tutti i sub-project). Questo comprende quindi il plugin <code>scala</code> e la sua configurazione, <code>scalatest</code> e <code>scoverage</code> per la gestione dei test, il plugin <code>spotless</code> per operazioni di lint-formatting del codice, varie opzioni comuni di configurazione del compilatore Scala, il plugin <code>git-sensitive-semantic-versioning</code> per la gestione dei numeri di versione delle release;</p></li>
<li><p><strong>scalaquest.libraries-conventions</strong>: definisce le configurazioni comuni a tutti i sotto-progetti che vanno a comporre una libreria Scala. Questo a sua volta importa il plugin <code>common-scala-conventions</code>, rendendo possibile configurare i moduli <em>Core</em> e <em>CLI</em> importando solamente <code>libraries-conventions</code>. Comprende il plugin <code>java-library</code>, la configurazione <code>scoverage</code> specifica per le librerie, e la configurazione necessaria per la pubblicazione su Maven Central.</p></li>
<li><p><strong>scalaquest.examples-conventions</strong>: definisce le configurazioni comuni a tutti i sotto-progetti <em>Examples</em>. Questo a sua volta importa il plugin <code>common-scala-conventions</code>, rendendo possibile configurare gli esempi importando solamente <code>examples-conventions</code>. Complende il plugin <code>application</code>, la configurazione di <code>scoversage</code> specifica per gli esempi, e la configurazione necessaria a rendere gli esempi giocabili da linea di comando.</p></li>
</ul>
<h1 data-number="4" id="sec:strategie-di-version-control"><span class="header-section-number">4</span> Strategie di Version Control</h1>
<p>Durante lo sviluppo del progetto, non si è adottato sempre lo stesso modello di sviluppo. Nelle prime fasi, durante le quali non si aveva del codice abbastanza stabile da essere “rilasciabile”, si è seguito un approccio più flessibile e prototipale, denominato <strong>GitHubFlow</strong>, per poi evolvere il modello ad un più strutturato <strong>GitFlow</strong>.</p>
<h2 data-number="4.1" id="sec:github-flow-in-fase-embrionale"><span class="header-section-number">4.1</span> GitHub Flow in fase embrionale</h2>
<p><strong>GitHub Flow</strong> è un modello di sviluppo ispirato a GitFlow, ma con alcune caratteristiche che lo rendono più flessibile e semplice da porre in atto.</p>
<p>Il modello richiede ad esempio che la versione stabile del software sia mantenuta su un branch <code>main</code> (o <code>master</code>), senza però la necessità di un branch <code>dev</code> parallelo. Allo stesso tempo, però, GitHub Flow suggerisce di organizzare il lavoro in <code>feature/*</code> branch, come in GitFlow, i quali confluiscono nel <code>main</code>.</p>
<p>Alla luce di ciò, le prime iterazioni di progetto hanno presentato particolare flessibilità sulle modalità di modifica del codice. Le varie feature sono state sviluppate sui rispettivi <code>feature/*</code> branch, poi riversati nel <code>main</code> tramite pull request. Si è subordinato la chiusura di queste alla revisione da parte di un membro del team (solitamente, non appartenente allo stesso sub-team, così da aggiornare l’altro team sui progressi di progetto) e al passaggio di determitati workflow di CI e QA (descritti al sec. 5).</p>
<p>Unica deroga a questo flusso di lavoro, è stata posta per modifiche minori, tali da non impattare sul funzionamento generale del codice (es. correzione di typo). Per queste è stato permesso il push diretto sul branch <code>main</code>.</p>
<h2 data-number="4.2" id="sec:gitflow-a-regime"><span class="header-section-number">4.2</span> GitFlow a regime</h2>
<p>Una volta predisposta una codebase sufficientemente stabile, e una volta abilitati i workflow di Continuous Delivery, si è migrato a un più strutturato modello <strong>GitFlow</strong>. Questo permette di avere nel branch <code>main</code> la versione ufficiale e stabile, sempre associata a una release. A ogni push nel <code>main</code> deve corrispondere un tag annotato, associato a sua volta a un numero di versione. La versione “di lavoro” del codice, parziale ma potenzialmente rilasciabile, risiede nel branch <code>dev</code>.</p>
<p>I vari <code>feature/*</code> branch confluiscono ora tramite pull request in <code>dev</code>, con gli stessi vincoli formulati per modello precedente (controlli di CI obbligatori e revisione di un utente obbligatoria), e la stessa deroga per le modifiche minori. In aggiunta, per una maggiore leggibilità e organizzazione del codice, si è adottata una precisa politica di merge, che prevede che queste pull request vengano chiuse tramite <strong>squash and merge</strong>, con un breve commento nel commit che ne identifichi il changelog.</p>
<p>Il <code>main</code> viene aggiornato tramite delle pull request sullo stesso originate da branch <code>release/X.Y.Z</code> (o <code>hotfix/X.Y.Z</code>), originati a loro volta dal <code>dev</code>; con <code>X.Y.Z</code> si intende un numero di versione, formulato secondo le regole del semantic versioning. Queste pull request presentano, oltre ai vincoli di validazione visti per le precedenti (controlli di CI e revisione di un membro del team obbligatoria), anche la necessità di presentare una coverage superiore al 75% nei moduli <em>Core</em> e <em>CLI</em>. Sono poi presenti degli accorgimenti ulteriori per la delivery automatizzata degli asset, e la gestione dei tag, indicati in sec. 6. Infine, una politica di merge ben precisa è adottata alla chiusura di queste pull request, le quali richiedono un <strong>merge commit</strong> che riporti, come commento del commit, un breve changelog<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<h1 data-number="5" id="sec:chap5"><span class="header-section-number">5</span> Continuous Integration, Quality Assurance</h1>
<p>Particolare sforzo è stato posto nel porre in atto workflow efficaci e automatizzati, in grado di garantire la qualità del codice, e la Contiuous Integration. Per la realizzazione di questi, si è utilizzato il tool <strong>GitHub Actions</strong>, in parte per la profonda integrazione con GitHub, e in parte a causa delle <a href="https://blog.travis-ci.com/2020-11-02-travis-ci-new-billing">recenti modifiche al piano di pricing in Travis CI</a>. Questi a loro volta sfruttano delle funzionalità integrate all’interno del progetto grazie al tool di build automation Gradle.</p>
<h2 data-number="5.1" id="sec:qualità-del-codice-gradle"><span class="header-section-number">5.1</span> Qualità del codice Gradle</h2>
<p>Uno dei primissimi accorgimenti posti in atto nel progetto ha riguardato dei controlli di qualità sul codice Kotlin dei convention plugin stessi, e nei file <code>build.gradle.kts</code> nei vari sotto-progetti. Lo scopo è stato quello di innalzare la qualità della stessa struttura Gradle a contorno del progetto, prima ancora di iniziare a lavorare nella codebase Scala vera e propria.</p>
<p>A tal scopo, è stato abilitato il plugin <code>detekt</code>, un linter per Kotlin, posto in modalità strict: in questo modo, la build gradle fallisce nel caso in cui il codice Kotlin non rispetti determinati requisiti qualitativi, riportati in maniera dichiarativa all’interno del file <code>/buildSrc/config/detekt.yml</code>.</p>
<p>Inoltre, per facilitare l’aggiornamento di dipendenze e plugin, è stato adottato il plugin <code>refreshVersions</code>, che consente di estrapolare le versioni di dipendenze e plugin Gradle in un file separato <code>versions.properties</code>, permettendo l’aggiornamento automatizzato delle stesse.</p>
<p>A tal proposito, a livello di organizzazione è stato definito un bot, denominato <strong><a href="https://github.com/scalaquest/Dependabot">Dependabot</a></strong> (nome ispirato al sistema di GitHub per l’aggiornamento delle dipendenze). Questo altro non è che una semplice repository con un workflow schedulato, eseguito automaticamente ogni notte, per rilevare all’interno delle varie repository di progetto eventuali dipendenze non aggiornate, e generando automaticamente una pull request nella quale si va ad aggiornare tale dipendenza. Tale bot sfrutta al suo interno <a href="https://github.com/DanySK/upgradle"><code>UpGradle</code></a>, configurandolo appositamente per agire su tutti i repository dell’organizzazione.</p>
<h2 data-number="5.2" id="sec:framework-di-test-e-soglie-di-coverage"><span class="header-section-number">5.2</span> Framework di test e soglie di coverage</h2>
<p>I test sono portati avanti tramite il framework <strong>ScalaTest</strong>, seguendo lo stile di test <strong>WordSpec</strong>. Integrare ScalaTest all’interno del progetto non si è rivelato banale. A seguito di varie ricerche, si è deciso di integrarli tramite il plugin <a href="https://github.com/maiflai/gradle-scalatest"><code>gradle-scalatest</code></a>, un plugin che integra e configura in maniera pressoché trasparente ScalaTest, basato su jUnit 5.</p>
<p>In aggiunta a questo, è stato utilizzato un secondo framework di test, per rendere possibile testare il modulo <em>CLI</em>. Basandosi infatti il modulo sulla libreria funzionale <strong>ZIO</strong>, il test dello stesso può essere effettuato solo con un framework apposito, basato sempre su jUnit, denomitato <code>zio-test-junit</code>.</p>
<p>Infine, si è reso necessario trovare un modo per poter gestire i <strong>controlli di coverage</strong>. È infatti noto che Jacoco, uno dei tool più diffusi per i controlli di coverage su JVM, mal si adatta ai controlli su sorgente Scala. Jacoco opera infatti a livello bytecode, andando a coprire del codice autogenerato da Scala, e che può portare a stime di coverage del tutto sballate. Lo stato dell’arte per la messa in atto di controlli di coverage Scala passa per l’utilizzo di framework dedicati che tengono conto di queste caratteristiche, come <strong>Scoverage</strong>. Esiste per questo un plugin dedicato, denominato <a href="https://github.com/scoverage/gradle-scoverage"><code>gradle-scoverage</code></a>. Questo permette di generare, tra gli altri, report di coverage in formato html, sia in forma aggregata che per i singoli sottoprogetti (task <code>:aggregateReportScoverage</code> e <code>:reportScoverage</code>), oltre ad esporre un task <code>:scoverageCheck</code>, che permette di far fallire la build in presenza di coverage più bassa di una determinata soglia. Si è quindi installato nel progetto questo plugin, andando anche a configurare una soglia di coverage mandatoria del 75% per i moduli <em>Core</em> e <em>CLI</em>.</p>
<h2 data-number="5.3" id="sec:lint-e-code-styling"><span class="header-section-number">5.3</span> Lint e code styling</h2>
<p>Particolare attenzione è stata posta anche alla qualità del codice e allo stile dello stesso, definendo una serie di vincoli atti ad innalzare la coesione stilistica del codice Scala tra le varie sezioni del progetto.</p>
<p>Sono presenti molteplici alternative in grado di gestire funzionalità di linting e styling di codice Scala tramite Gradle. Si è deciso a tal scopo di utilizzare il plugin <code>spotless</code>: questo aggiunge al progetto vari task per lo styling automatico del codice (<code>:spotlessApply</code>) e per il check dello stesso (<code>:spotlessCheck</code>), supportando al contempo molteplici linguaggi di programmazione tramite tecniche differenti. Per Scala, Spotless sfrutta internamente <code>scalafmt</code>, un tool per lo styling del codice Scala. Le regole di styling applicate sono accessibili in un formato dichiarativo all’interno del file <code>.scalafmt.conf</code>.</p>
<h2 data-number="5.4" id="sec:sonarcloud"><span class="header-section-number">5.4</span> SonarCloud</h2>
<p>Un ulteriore strumento posto in atto per innalzare la qualità del codice e certificarla è <strong>SonarCloud</strong>. Questo tool permette di porre in atto controlli automatizzati sul codice, estraendo varie metriche qualitative riguardo la codebase, legate a mantenibilità, coverage, debito tecnico, duplicazione e molto altro. Lo strumento fornisce inoltre una dashboard pubblica che ne raccoglie le principali metriche, accessibile <a href="https://sonarcloud.io/dashboard?id=scalaquest_PPS-19-ScalaQuest">a questo link</a>.</p>
<p>Di particolare rilevanza per il progetto è stata la funzionalità <strong>quality gate</strong>: SonarCloud integra infatti un bot, che ad ogni push all’interno di una pull request in direzione di branch stabili, effettua un controllo di CI, fallendo nel caso in cui le metriche rilevate non superino delle soglie preimpostate.</p>
<p>Allo scopo di configurare correttamente SonarCloud, si è reso necessario aggiungere un plugin al progetto, denominato <code>sonarqube</code>. Questo rappresenta uno strumento cosiddetto di “scanner” per SonarCloud, andando ad estrarre in maniera più mirata le metriche. Il plugin fornisce il task <code>:sonarqube</code>, che va eseguito in CI nel momento in cui si voglia eseguire un controllo di quality gate.</p>
<h2 data-number="5.5" id="sec:il-workflow-ci"><span class="header-section-number">5.5</span> Il workflow CI</h2>
<p>Allo scopo di porre in atto la maggior parte dei controlli citati in precedenza, si è reso necessario definire un apposito workflow GitHub Actions, definito all’interno del file <code>ci.yml</code>. Questo viene eseguito ad ogni push e pull request effettuata in direzionde dei branch <code>main</code> e <code>dev</code>. Il workflow è stato organizzato in differenti job, i quali agiscono in maniera completamente parallela. Ciò permette di ottenere una logica di tipo fail-fast, desiderabile nelle routine di CI. I job eseguiti sono i seguenti:</p>
<ul>
<li><p><strong>Build</strong>: responsabile di verificare che il software venga effettuata correttamente la build. Il task <code>:build</code> viene in questo caso “sezionato” nei suoi due sotto-task <code>:assemble</code> e <code>:check</code>, permettendo una più facile interpretazione dei log in caso di fail. Il job viene eseguito su una matrice di sistemi operativi, mentre non si è ritenuto di interesse testare la build su versioni differenti di Java (avendo posto come requisito il solo supporto a Java 11 con Scala 2.13);</p></li>
<li><p><strong>Lint</strong>: responsabile della correttezza stilistica del codice. Al suo interno, viene semplicemente eseguito il task <code>:spotlessCheck</code>;</p></li>
<li><p><strong>Coverage</strong>: controlla che le soglie di coverage impostate vengano rispettate, tramite il task <code>:checkScoverage</code>.</p></li>
</ul>
<h2 data-number="5.6" id="sec:il-workflow-opt-in-ci"><span class="header-section-number">5.6</span> Il workflow Opt-in CI</h2>
<p>Ulteriore controllo di CI è stato posto tramite il workflow definito nel file <code>opt-in-ci.yml</code>. Questo permette di attivare determitate funzioni di CI, come lo style check, la build, o il controllo di coverage, a partire dai branch <code>feature/*</code>. Viene definito “opt-in” in quanto di base questi controlli sono disabilitati; vengono di fatto utilizzati solo per dei test, e possono essere invocati includendo, nel contenuto del commit che ha generato il push nel branch, i tag <code>[lint]</code>, <code>[build]</code>, <code>[coverage]</code>.</p>
<h1 data-number="6" id="sec:chap6"><span class="header-section-number">6</span> Continuous Delivery e Deployment</h1>
<p>Tra gli obiettivi di progetto è stato posto fin da subito quello di realizzare dei processi efficaci di Continuous Delivery e Deployment degli asset. Nonostante ciò, a differenza di quanto fatto per i workflow di CI, quelli di CD non sono stati realizzati immediatamente. Questo in quanto nei primi Sprint di progetto non si aveva del codice abbastanza stabile da poterne ricavare degli asset concretamente utilizzabili. I workflow di Continuous Delivery e Deployment sono stati predisposti durante il passaggio da GitHubFlow a GitFlow, e hanno subìto diverse modifiche lungo lo sviluppo del progetto.</p>
<h2 data-number="6.1" id="sec:il-workflow-release"><span class="header-section-number">6.1</span> Il workflow Release</h2>
<p>Il primo e più importante workflow per il delivery degli asset viene definito nel file <code>release.yml</code>. Questo viene lanciato ogni qualvolta viene chiusa con successo (ovvero generando un evento di merge) una pull request in direzione del <code>main</code>, a partire da un branch <code>release/X.Y.Z</code>. Tale workflow:</p>
<ol type="1">
<li><p>Inferisce il nome del tag da associare alla release, a partire dal nome del branch di provenienza, e crea un annotated tag in corrispondenza del commit di merge;</p></li>
<li><p>Genera una release GitHub nell’apposita sezione Releases, ponendo all’interno di questa gli asset necessari (i <code>jar</code> per i moduli <em>Core</em> e <em>CLI</em>, le distribution degli esempi in formato <code>zip</code> e <code>tar.gz</code>, il file <code>README.md</code>);</p></li>
<li><p>In parallelo al punto 2, effettua una pubblicazione su Maven Central;</p></li>
<li><p>Una volta completati i punti 2 e 3, viene generata una pull request dal <code>main</code>, diretta al branch <code>dev</code>. Ciò permette di integrare nel branch di sviluppo le eventuali modifiche occorse all’interno dei branch <code>release/X.Y.Z</code>. Su di questi infatti si è delle volte agito con delle modifiche minori.</p></li>
<li><p>Una volta completati i punti 2 e 3, vengono generati ScalaDoc e report di coverage per i moduli <em>Core</em> e <em>CLI</em>, e resi disponibili nello spazio web del progetto.</p></li>
</ol>
<h2 data-number="6.2" id="sec:il-workflow-prerelease"><span class="header-section-number">6.2</span> Il workflow Prerelease</h2>
<p>Oltre al workflow di release principale, si è predisposto un secondo workflow definito nel file <code>prerelease.yml</code>, che va a creare delle release GitHub ogni qualvolta viene effettuato un push nel branch <code>dev</code>. Tali release vengono marcate come non perfettamente stabili con il marcatore prerelease, da cui il nome del workflow. Particolarità di questa routine è che non necessita di definire manualmente il nome del tag associato: questo viene generato in automatico, tramite il plugin <a href="https://github.com/DanySK/git-sensitive-semantic-versioning-gradle-plugin/blob/master/src/main/kotlin/org/danilopianini/gradle/gitsemver/GitSemVer.kt"><code>git-sensitive-semantic-versioning</code></a>, sulla base dell’ultimo tag annotato disponibile.</p>
<p>Ricapitolando, il workflow:</p>
<ol type="1">
<li><p>Inferisce il nome del tag da associare alla prerelease, in modo del tutto automatico, tramite il plugin Gradle <a href="https://github.com/DanySK/git-sensitive-semantic-versioning-gradle-plugin/blob/master/src/main/kotlin/org/danilopianini/gradle/gitsemver/GitSemVer.kt"><code>git-sensitive-semantic-versioning</code></a>. Un task personalizzato permette di estrarre il numero di versione e di salvarlo su un file; il contenuto viene quindi prelevato, salvato come variabile d’ambiente, e viene creato un lightweight tag in corrispondenza del commit di merge;</p></li>
<li><p>Genera una release GitHub nell’apposita sezione Releases, con il flag prerelease abilitato, ponendo all’interno di questa gli asset necessari (i <code>jar</code> per i moduli <em>Core</em> e <em>CLI</em>, le distribution degli esempi in formato <code>zip</code> e <code>tar.gz</code>, il file <code>README.md</code>);</p></li>
<li><p>In parallelo al punto 2, effettua una pubblicazione su Maven Central.</p></li>
</ol>
<h2 data-number="6.3" id="sec:maven-central"><span class="header-section-number">6.3</span> Maven Central</h2>
<p>Si è deciso di dedicare una sezione a parte per approfondire il procedimento che ha portato alla pubblicazione delle librerie di progetto sul repository pubblico <strong>Maven Central</strong>.</p>
<p>La predisposizione del delivery in un repository pubblico è stata prevista sin dall’inizio nel progetto. Anche solo la scelta di porre tutti i repository di progetto sotto una stessa organizzazione <code>scalaquest</code> è stata eseguita in quest’ottica, così da poter ottenere il dominio <code>scalaquest.github.io</code>, e utilizzare <code>io.github.scalaquest</code> quale groupId per il rilascio.</p>
<p>L’attuazione di questo obiettivo però è stato demandato a fasi più avanzate di progetto, individuando tale possiblità come requisito da valutare in corso d’opera.</p>
<p>Ci si è iniziati a muovere in tal senso durante la migrazione da GitHubFlow a GitFlow. In questo frangente si è aperto un <a href="https://issues.sonatype.org/browse/OSSRH-63868?page=com.atlassian.jira.plugin.system.issuetabpanels%3Aall-tabpanel"><strong>ticket presso Sonatype</strong></a>, richiedendo la possibilità di pubblicare sotto il groupId <code>io.github.scalaquest</code>.</p>
<p>Tale processo è stato completato abbastanza velocemente. Lo sviluppo di questa soluzione ha però subito a questo punto una fase d’arresto, legata principalmente alla complessità nella configurazione del plugin Gradle <code>maven-publish</code> e alla firma degli asset, in particolare in ambiente CI. I workflow di release sono quindi stati inizialmente realizzati senza la possibilità di pubblicare su Maven.</p>
<p>Solo più avanti, con il raggiungimento di una relativa stabilità di progetto, si è deciso di approfondire e portare a termine questo task, concludendo la configurazione del plugin e dei workflow collegati.</p>
<p>Una volta pubblicati gli asset, saranno i membri del team a concludere la release, effettuando il <em>close</em> o il <em>drop</em> della release, direttamente dall’interfaccia web <strong>Nexus Repository Manager</strong>, previa autenticazione.</p>
<p>Il team tiene a sottolineare che pubblicare su una repository pubblica popolare quale Maven Central è stata una grande fonte di soddisfazione per i propri membri.</p>
<h1 data-number="7" id="sec:il-repository-dedicato-alla-documentazione"><span class="header-section-number">7</span> Il repository dedicato alla documentazione</h1>
<p>Nelle prime fasi del progetto, il repository principale conteneva un ulteriore sotto-progetto denominato <code>reports</code>. All’interno di questo si sono andati a porre i report di LSS e PPS, oltre ai documenti a margine, come lo Sprint Overview. La scelta di utilizzare un sotto-progetto è stata dettata dalla necessità di dare una struttura al codice, e alla possilità di utilizzare il plugin <code>spotless</code> di Gradle anche per lo styling del Markdown, grazie ai task <code>:spotlessCheck</code> per il controllo sul rispetto delle regole di stile, e <code>:spotlessApply</code> per l’applicazione automatica delle stesse.</p>
<p>Con l’aumentare della complessità di progetto, però, si è deciso di modificare tale infrastruttura. Il sottoprogetto <code>reports</code> è stato quindi migrato in un repository del tutto scollegato da quello principale, denominato <a href="https://github.com/scalaquest/Reports"><strong>scalaquest/Reports</strong></a>. La scelta è stata dettata anche allo scopo di costruire un’infrastruttura più complessa attorno ai report stessi.</p>
<p>Reports è ancora una volta un progetto Gradle, con abilitato il plugin <code>spotless</code> per lo styling (con una configurazione dedicata per il Markdown), e i sorgenti della documentazione (in Markdown) contenuti all’interno della directory <code>/src</code>. Il modello di sviluppo adottato è ancora una volta GitFlow, in maniera del tutto equivalente nelle modalità a quelle del repository principale.</p>
<h2 data-number="7.1" id="sec:continuous-integration"><span class="header-section-number">7.1</span> Continuous Integration</h2>
<p>A guardia dei branch stabili, è stato posto un workflow di CI, definito nel file <code>ci.yml</code> che va ad applicare <code>:spotlessCheck</code>, e fallisce nel caso in cui non vengano rispettate determinate regole di stile (come la lunghezza della riga posta a 80 caratteri).</p>
<h2 data-number="7.2" id="sec:continuous-delivery-e-deployment"><span class="header-section-number">7.2</span> Continuous Delivery e Deployment</h2>
<p>Assolutamente peculiari sono invece i workflow di delivery e deployment. I file Markdown si prestano infatti molto bene ad essere convertiti in altri formati, utilizzando i tool adatti. Si è deciso quindi di fornire, per una consultazione più agevole, i report nei formati LaTeX PDF e in una versione web, autogenerati ad ogni nuova release. Ciò è stato possibile grazie a <strong>Pandoc</strong>, un tool che permette la conversione di file testuali in una moltitudine di formati differenti.</p>
<p>Con queste specifiche, si sono andati quindi a definire un workflow <strong>Release</strong> e uno <strong>Prerelease</strong>, lanciati con le stesse modalità descritte per il repository principale.</p>
<h3 data-number="7.2.1" id="sec:il-workflow-release-1"><span class="header-section-number">7.2.1</span> Il workflow Release</h3>
<p>Questo, definito nel file <code>release.yml</code>, viene lanciato alla chiusura dei branch <code>release/X.Y.Z</code>. Effettua le seguenti operazioni:</p>
<ol type="1">
<li><p>Inferisce il nome del tag da associare alla release, a partire del nome del branch di provenienza, e crea un annotated tag in corrispondenza del commit di merge;</p></li>
<li><p>Genera una release GitHub nell’apposita sezione Releases. Tale release contiene i report di PPS, LSS e un file di appendice (oltre al file <code>README.md</code>), a partire dai file Markdown, tramite un’immagine Docker con integrata un’installazione Pandoc;</p></li>
<li><p>Genera una versione HTML dei report e del file di appendice, a partire dai file Markdown, tramite un’immagine Docker con integrata un’installazione Pandoc. Posiziona quindi tali file all’interno del branch <code>gh-pages</code>, e effettua automaticamente un commit su questo branch, integrando la versione aggiornata della documentazione. In questo modo, questa sarà accessibile dallo spazio web del progetto;</p></li>
<li><p>Una volta completati i punti 2 e 3, viene generata una pull request dal <code>main</code>, diretta al branch <code>dev</code>. Ciò permette di integrare nel branch di sviluppo le eventuali modifiche occorse all’interno dei branch <code>release/X.Y.Z</code>. Su di questi infatti si è delle volte agito con delle modifiche minori.</p></li>
</ol>
<h3 data-number="7.2.2" id="sec:il-workflow-prerelease-1"><span class="header-section-number">7.2.2</span> Il workflow Prerelease</h3>
<p>Questo, definito nel file <code>prerelease.yml</code> viene lanciato ad ogni push nel branch <code>dev</code>, e genera delle release marcate con il flag prerelease, con numero di versione generato automaticamente tramite <a href="https://github.com/DanySK/git-sensitive-semantic-versioning-gradle-plugin/blob/master/src/main/kotlin/org/danilopianini/gradle/gitsemver/GitSemVer.kt"><code>git-sensitive-semantic-versioning</code></a>. Effettua le seguenti operazioni:</p>
<ol type="1">
<li><p>Inferisce il nome del tag da associare alla prerelease, in modo del tutto automatico, tramite il plugin Gradle <a href="https://github.com/DanySK/git-sensitive-semantic-versioning-gradle-plugin/blob/master/src/main/kotlin/org/danilopianini/gradle/gitsemver/GitSemVer.kt"><code>git-sensitive-semantic-versioning</code></a>. Un task personalizzato permette di estrarre il numero di versione e salvarlo su un file; il contenuto viene quindi prelevato, salvato come variabile d’ambiente, e viene creato un lightweight tag in corrispondenza del commit di merge;</p></li>
<li><p>Genera una release GitHub nell’apposita sezione Releases, con il flag prerelease abilitato. Tale release contiene i report di PPS, LSS e un file di appendice (oltre al file <code>README.md</code>), a partire dai file Markdown, tramite un’immagine Docker con integrata un’installazione Pandoc.</p></li>
</ol>
<h2 data-number="7.3" id="sec:configurazione-di-pandoc"><span class="header-section-number">7.3</span> Configurazione di Pandoc</h2>
<p>Per poter personalizzare l’output generato da Pandoc, sono stati utilizzati dei file di configurazione, accessibli dalla directory <code>/pandoc</code>. All’interno di questa si è andato a configurare il template LaTeX nativo di Pandoc, allo scopo di adattarlo al progetto. Per quanto riguarda il template HTML, invece, si è creato e utilizzato un template custom, a partire da un fork del template <a href="https://github.com/ashki23/pandoc-bootstrap"><strong>ashki23/PandocBootstrap</strong></a>. Il template di progetto è accessibile al repository <a href="https://github.com/scalaquest/PandocBootstrap"><strong>scalaquest/PandocBootstrap</strong></a>. Questo è stato posto come submodule del repository <em>scalaquest/Report</em>, così da avere a disposizione il template durante la generazione dei report in CI.</p>
<h1 data-number="8" id="sec:conclusioni"><span class="header-section-number">8</span> Conclusioni</h1>
<p>In conclusione, possiamo affermare come team di ritenerci molto soddisfatti di quanto fatto in questo progetto. Rispetto a progetti trattati in precedenza dai singoli membri del gruppo, si è posta un’attenzione particolare alla metodologia e all’organizzazione di progetto, cercando per quanto possibile di approcciare lo sviluppo con mentalità ingegneristica, pragmatica e strutturata.</p>
<p>Le sessioni di knowledge crunching iniziali si sono rivelate cruciali per la comprensione dei concetti alla base del progetto, e per l’organizzazione dello stesso. È stata una vera e propria soddisfazione poi vedere il proprio progetto pubblicato sulla repository pubblica Maven Central.</p>
<p>Come membri del team ci teniamo inoltre ad aggiungere che nessuno di noi aveva in precedenza lavorato ad un progetto con un’organizzazione e una metodologia così strutturata. Due membri del team provengono poi da una triennale differente dal percorso degli altri (Riccardo Maldini e Francesco Gorini, UniUrb), la quale proponeva un approccio ai progetti ben più approssimativo. Una sfida che si è accettata di buon grado, coscienti delle potenzialità dei singoli.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>È necessario far presente che alcuni problemi sono incorsi tra la release 0.3.1 e 0.4.0, frangente nel quale, a seguito di un errore nelle politiche di commit, si è dovuto agire tramite rebase per preservare la repository. La storia tra questi due tag risulta quindi non perfettamente lineare.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div>
            <div class="d-none d-xl-block col-xl-3 bd-toc">
               <ul class="section-nav">
                  <li class="toc-entry"><ul>
<li><a href="#sec:introduzione"><span class="toc-section-number">1</span> Introduzione</a>
<ul>
<li><a href="#sec:sorgenti"><span class="toc-section-number">1.1</span> Sorgenti</a></li>
</ul></li>
<li><a href="#sec:aspetti-di-domain-driven-design"><span class="toc-section-number">2</span> Aspetti di Domain Driven Design</a>
<ul>
<li><a href="#sec:knowledge-crunching"><span class="toc-section-number">2.1</span> Knowledge Crunching</a></li>
<li><a href="#sec:ubiquitous-language"><span class="toc-section-number">2.2</span> Ubiquitous Language</a></li>
<li><a href="#sec:individuazione-dei-requisiti-e-dei-casi-duso"><span class="toc-section-number">2.3</span> Individuazione dei requisiti e dei casi d’uso</a></li>
<li><a href="#sec:bounded-context-e-context-map"><span class="toc-section-number">2.4</span> Bounded context e Context map</a></li>
</ul></li>
<li><a href="#sec:gradle-e-struttura-multi-progetto"><span class="toc-section-number">3</span> Gradle e struttura multi-progetto</a>
<ul>
<li><a href="#sec:strategia-basata-su-convention-plugin"><span class="toc-section-number">3.1</span> Strategia basata su convention plugin</a></li>
</ul></li>
<li><a href="#sec:strategie-di-version-control"><span class="toc-section-number">4</span> Strategie di Version Control</a>
<ul>
<li><a href="#sec:github-flow-in-fase-embrionale"><span class="toc-section-number">4.1</span> GitHub Flow in fase embrionale</a></li>
<li><a href="#sec:gitflow-a-regime"><span class="toc-section-number">4.2</span> GitFlow a regime</a></li>
</ul></li>
<li><a href="#sec:chap5"><span class="toc-section-number">5</span> Continuous Integration, Quality Assurance</a>
<ul>
<li><a href="#sec:qualità-del-codice-gradle"><span class="toc-section-number">5.1</span> Qualità del codice Gradle</a></li>
<li><a href="#sec:framework-di-test-e-soglie-di-coverage"><span class="toc-section-number">5.2</span> Framework di test e soglie di coverage</a></li>
<li><a href="#sec:lint-e-code-styling"><span class="toc-section-number">5.3</span> Lint e code styling</a></li>
<li><a href="#sec:sonarcloud"><span class="toc-section-number">5.4</span> SonarCloud</a></li>
<li><a href="#sec:il-workflow-ci"><span class="toc-section-number">5.5</span> Il workflow CI</a></li>
<li><a href="#sec:il-workflow-opt-in-ci"><span class="toc-section-number">5.6</span> Il workflow Opt-in CI</a></li>
</ul></li>
<li><a href="#sec:chap6"><span class="toc-section-number">6</span> Continuous Delivery e Deployment</a>
<ul>
<li><a href="#sec:il-workflow-release"><span class="toc-section-number">6.1</span> Il workflow Release</a></li>
<li><a href="#sec:il-workflow-prerelease"><span class="toc-section-number">6.2</span> Il workflow Prerelease</a></li>
<li><a href="#sec:maven-central"><span class="toc-section-number">6.3</span> Maven Central</a></li>
</ul></li>
<li><a href="#sec:il-repository-dedicato-alla-documentazione"><span class="toc-section-number">7</span> Il repository dedicato alla documentazione</a>
<ul>
<li><a href="#sec:continuous-integration"><span class="toc-section-number">7.1</span> Continuous Integration</a></li>
<li><a href="#sec:continuous-delivery-e-deployment"><span class="toc-section-number">7.2</span> Continuous Delivery e Deployment</a>
<ul>
<li><a href="#sec:il-workflow-release-1"><span class="toc-section-number">7.2.1</span> Il workflow Release</a></li>
<li><a href="#sec:il-workflow-prerelease-1"><span class="toc-section-number">7.2.2</span> Il workflow Prerelease</a></li>
</ul></li>
<li><a href="#sec:configurazione-di-pandoc"><span class="toc-section-number">7.3</span> Configurazione di Pandoc</a></li>
</ul></li>
<li><a href="#sec:conclusioni"><span class="toc-section-number">8</span> Conclusioni</a></li>
</ul></li>
               </ul>
            </div>
         </div>
               </div>
            <!-- JS, Popper.js, and jQuery -->
      <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
      <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
      <!-- Mathjax -->
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script>
         /* Bootstrap styles to tables */
         function bootstrapStylePandocTables() {
         $('tr.header').parent('thead').parent('table').addClass('table table-condensed'); }
         $(document).ready(function () { bootstrapStylePandocTables(); });
         /* Adjust the height when click the toc */
         var shiftWindow = function() { scrollBy(0, -60) };
         window.addEventListener("hashchange", shiftWindow);
         function load() { if (window.location.hash) shiftWindow(); }
      </script>
   </body>
</html>
